# Gemini 행동 지침 (gemini-workspace)

이 문서는 Gemini가 이 워크스페이스에서 작업을 수행할 때 따라야 할 최우선 규칙과 절차를 정의합니다.

---

## I. 핵심 운영 환경 (Core Operating Environment)

**1. 사용자 환경: Windows**
- **주 운영체제:** 이 워크스페이스의 주 운영체제는 **Windows** 입니다.
- **절대 준수:** 모든 파일 경로, 셸 명령어, 환경 변수 등은 Windows 표준을 따라야 합니다.

**2. Gemini의 실행 환경과 주의점**
- **환경 차이:** Gemini의 도구(Tool) 실행 환경은 Linux 기반일 수 있습니다. 이로 인해 Windows 명령어(`del`, `copy`) 대신 Linux 명령어(`rm`, `cp`)를 사용하려는 실수가 발생할 수 있습니다.
- **핵심 행동 규칙:** 모든 명령어 실행 전, **사용자 환경이 Windows임을 반드시 인지**하고 Windows에 맞는 명령어를 사용해야 합니다. 실패 시 OS 환경 차이를 가장 먼저 의심하고 수정합니다.

**3. 작업 공간 제한**
- **절대 원칙:** 모든 파일 작업은 `%USERPROFILE%\gemini-workspace` 디렉터리 안에서만 수행해야 합니다. 이 디렉터리 외부의 어떤 파일 시스템 경로에도 접근하거나 파일을 생성해서는 안 됩니다.

**4. 사용 언어**
- **기본 언어:** 사용자와의 모든 상호작용은 **한국어**로 진행하는 것을 원칙으로 합니다.

**5. Git 관리 폴더**
- **`projects/`:** 각 프로젝트는 별도의 Git 저장소로 관리되므로, 메인 워크스페이스 Git 저장소에서는 추적하지 않습니다. `.gitignore` 파일에서 `/projects/` 라인은 항상 유지되어야 합니다.
- **`scratchpad/`:** 임시 작업 및 테스트를 위한 공간으로, Git에 의해 추적됩니다. 이 폴더 내의 변경사항은 커밋에 포함될 수 있습니다.

---

## II. 표준 작업 절차 (Standard Workflows)

**1. 세션 시작**
- 모든 대화 세션을 시작할 때, 이 `GEMINI.md` 파일을 가장 먼저 읽고 모든 규칙을 인지한 상태에서 작업을 시작해야 합니다.

**2. `.gitignore` 관리**
- **작업 시작 시:** 프로젝트 관련 작업을 시작할 때, 루트 `.gitignore` 파일에서 `/projects/` 라인을 찾아 주석 처리(`#/projects/`)합니다. (필요시 사용자에게 제안)
- **작업 종료 시:** 작업 완료 또는 세션 종료 시, 다시 `/projects/` 라인의 주석을 제거하여 복원합니다. (자동 또는 사용자에게 제안)
- **`projects` 폴더 이유:** `projects` 폴더 내 각 프로젝트는 별도 Git 저장소로 관리됩니다.
- **`scratchpad` 폴더:** `scratchpad` 폴더는 Git에 의해 추적되므로, `.gitignore`에서 `/scratchpad/` 라인은 제거되어야 합니다.

**3. 민감 정보 처리**
- **핵심 파일:** `secrets/my_sensitive_data.md` (Git 추적 제외)
- **절차:**
    1. 새로운 민감 정보 발견/생성 시, 즉시 `secrets/my_sensitive_data.md` 파일에 명확한 형식으로 기록합니다.
    2. 기록 후, 사용자에게 **"새로운 [정보 종류] 정보를 `secrets/my_sensitive_data.md` 파일에 기록했습니다. 내용을 확인하고 안전하게 관리해 주세요."** 라고 즉시 알립니다.
    3. **경고:** 민감 정보 자체를 대화창에 절대 노출해서는 안 됩니다.

**4. Git 커밋 (Windows 환경)**
- **문제:** `git commit -m "메시지"` 명령어의 문자열 처리 문제.
- **우회 절차:**
    1. `COMMIT_MSG.tmp` 임시 파일에 커밋 메시지를 작성합니다.
    2. `git commit -F COMMIT_MSG.tmp` 명령어로 커밋합니다.
    3. 성공 시, `del COMMIT_MSG.tmp` 명령어로 임시 파일을 즉시 삭제합니다.

---

## III. 주요 문제 해결 (Troubleshooting)

**1. `.gitignore`와 파일 접근 불가**
- **문제:** `.gitignore` 설정으로 인해 특정 파일이 보이지 않거나 접근이 안 될 수 있습니다.
- **해결책:** 파일이 존재해야 하는데 없다고 판단될 경우, **`respect_git_ignore=False`** 옵션을 사용하여 다시 파일 읽기를 시도합니다.

**2. 파일 및 폴더 삭제 안정화 (Python 활용)**

  * **문제**: Windows 환경에서 `del` 또는 `powershell Remove-Item` 명령어가 파일/폴더 삭제에 실패하거나 예상치 못한 오류를 반환할 수 있습니다.
  * **해결책**: Python의 `os.remove()` (파일 삭제) 및 `shutil.rmtree()` (폴더 삭제) 함수를 활용한 스크립트를 실행하여 안정적으로 삭제를 수행합니다.

    > **파일 삭제 실행 로직 (Python):**
    > ```python
    > import os
    > file_to_delete = r'[파일 경로]' # raw string으로 경로 지정
    > try:
    >     os.remove(file_to_delete)
    >     print(f"Successfully deleted: {file_to_delete}")
    > except OSError as e:
    >     print(f"Error deleting file {file_to_delete}: {e}")
    > ```
    >
    > **폴더 삭제 실행 로직 (Python):**
    > ```python
    > import os
    > import shutil
    > dir_to_delete = r'[폴더 경로]' # raw string으로 경로 지정
    > try:
    >     shutil.rmtree(dir_to_delete) # 비어있지 않은 폴더도 삭제
    >     print(f"Successfully deleted directory: {dir_to_delete}")
    > except OSError as e:
    >     print(f"Error deleting directory {dir_to_delete}: {e}")
    > ```
    >
    > **실행 방법:** 위 Python 코드를 임시 `.py` 파일로 저장한 후 `python [임시 파일 경로]` 명령어로 실행합니다.

---

## IV. 지능형 작업 기록 시스템 (Intelligent Logging System)

**1. 목적**
- 컨텍스트 손실 없는 완벽한 작업 인계 및 재개를 위함.
- Gemini가 능동적으로 기록을 관리하여 사용자의 부담을 제로(Zero)로 만듦.

**2. 핵심 파일**
- **`docs/HUB.md`:** 모든 작업의 중앙 관제 허브.
- **`docs/tasks/[task_id]/log.md`:** 개별 작업의 상세 타임라인.

**3. 기록 주기 설정 (Logging Cycle Configuration) - ★★★★★**
- **현재 설정: `Standard`**
- Gemini는 아래 설정에 따라 기록 시점을 조절한다. 사용자가 "사이클이 너무 길어/짧아"라고 피드백하면 이 설정을 변경한다.
    - `Detailed`: 파일 수정, 명령어 실행 등 **거의 모든 유의미한 행동 후** 기록을 제안.
    - `Standard` (기본값): 테스트 통과, 기능 구현 완료, 주요 문제 해결 등 **중요한 작업 단위(체크포인트)가 끝났을 때** 기록을 제안.
    - `Minimal`: 사용자가 명시적으로 "기록해줘"라고 하거나, 세션을 종료할 때만 기록.

**4. Gemini 기록 사이클 (Gemini Logging Cycle) - 강제 규칙**

**A. 세션 시작 시:**
1.  **무조건 `docs/HUB.md` 파일을 읽는다.**
2.  HUB의 `Active/Paused Tasks` 목록을 사용자에게 **즉시 브리핑한다.**
    > "현재 진행 중이거나 일시 중지된 작업은 다음과 같습니다: [작업 목록]. 어떤 작업을 계속할까요? 아니면 새로운 작업을 시작할까요?"
    (참고: '일시 중지'와 '진행 중'은 모두 현재 작업 중인 상태로 간주하며, 사용자에게는 통합하여 브리핑합니다.)
3.  `HUB.md`에 `__lastSession__` 블록이 있는지 확인하고, 존재하면 사용자에게 복구 여부를 질문한 후 해당 블록을 삭제한다.

**B. 작업 진행 중 (체크포인트 도달 시):**
1.  현재 설정된 **기록 주기에 따라** 체크포인트 도달을 인지한다.
2.  `git diff`를 사용하여 변경분을 요약하고, 수행한 작업 로그를 생성하여 **먼저 제안하고, 동의를 구한다.**
    > "작업이 완료되었습니다. 다음과 같이 로그에 기록할까요? (Y/N/Edit)"
    - **Attempt Index 규칙**
      - 동일 목표를 재시도할 때, `## 과정` 서브섹션에 1번부터 시작해 **실패마다 +1** 로 번호를 올려 기록한다.
      - 이미 사용한 번호를 다시 쓰지 않는다. (예: 1 → 2 → 3 …)
3.  사용자 피드백을 반영하여 `log.md`에 기록한다. 사용자가 거부하면 기록하지 않되, 다음 체크포인트에서 다시 제안한다.
4.  `HUB.md`의 현재 작업 `lastTouched` 타임스탬프를 갱신하고 커밋을 제안한다.

**C. 세션 종료 시 (사용자가 대화 종료 의사를 밝힐 때):**
1.  **`.gitignore` 복원 확인:** 루트 `.gitignore` 파일에서 `/projects/` 라인의 주석이 제거되었는지 확인하고, 필요시 복원(`replace` 도구 사용)을 제안한다.
    > "세션을 종료하기 전에, `.gitignore` 파일의 `/projects/` 라인 주석을 복원할까요?"
2.  **미커밋 검사 및 WIP 커밋 제안:** `git status`를 실행하여 `dirty tree`를 확인하고, 변경사항이 있으면 `WIP: Session End Backup` 임시 커밋을 제안한다.
3.  **HUB 업데이트:** 현재 작업 상태를 `Paused`로 갱신한다.
4.  **`__lastSession__` 블록 작성:** 활성 작업이 있는 경우, `HUB.md` 최하단에 `__lastSession__` YAML 블록(활성 작업 ID, 변경된 파일 목록, 타임스탬프 포함)을 추가하여 다음 세션 복구를 위한 컨텍스트를 저장한다.
5.  **최종 보고:** "모든 기록이 저장되었고 환경이 정리되었습니다 – 안전 종료." 라고 확답을 제공한다.

---

## V. 고급 기능 및 예외 처리

### 1. NLP Alias 규칙 명문화

사용자의 자연어 명령을 제가 어떻게 해석하고 어떤 표준 운영 절차(SOP)로 매핑하는지 명확히 정의하여 투명성을 확보합니다.

| 사용자 발화 예시 (자연어) | 저의 해석 (내부 명령) | 대응 절차 (SOP) |
| :--- | :--- | :--- |
| "시작!", "왔어", "뭐하지?" | `g start` | **SOP-1 (세션 시작)** |
| "잠깐 멈춰", "pause" | `g pause` | **SOP-2 (작업 상태 변경)** |
| "다시 하자", "resume" | `g resume` | **SOP-2 (작업 상태 변경)** |
| "끝내자", "퇴근", "종료" | `g end` | **SOP-3 (세션 종료)** |
| "되돌려줘", "undo", "롤백" | `g rollback` | **SOP-4 (롤백)** |

### 2. 간소화된 Post-mortem 프로세스

치명적인 오류 발생 시, 완전 자동화를 고집하는 대신 다음과 같은 간소화된 절차를 따르겠습니다.

1.  오류를 감지하면, `write_file` 도구를 사용하여 `docs/tasks/<task-id>/postmortem-YYYYMMDD.md` 파일을 생성합니다.
2.  파일에는 `# Post-mortem - YYYY-MM-DD` 와 같은 기본 헤더만 기록합니다.
3.  사용자에게 "오류 분석을 위해 `[파일 경로]`에 Post-mortem 파일을 생성했습니다. 관련 오류 로그나 상황 설명을 붙여넣어 주세요." 라고 명확히 안내합니다.

### 3. CI 연동 문구 공식화

`GEMINI.md` 가이드의 '규칙 수정' 관련 섹션에 아래 문장을 명시적으로 추가하여, CI/CD 파이프라인과의 연동을 공식화하겠습니다.

> "본 가이드의 수정 사항은 Pull Request 생성 시 `gemini-lint.yml` 워크플로우에 의해 자동으로 검증됩니다."

### 4. 기록 정정 프로세스 (Log Correction)

*   이미 커밋된 로그에 오류가 발견된 경우, 다음 절차에 따라 수정합니다.
*   **규칙:** 기존 로그를 삭제하거나 수정하지 않고, **변경 이력을 보존하기 위해** 그 아래에 수정 내용을 추가합니다.
    > **로그 파일에 추가할 내용 예시:**
    > ```
    > (여기에 수정된 내용 작성)
    > ```
*   수정 후에는 `fix(log): [task-id]의 로그 기록 수정` 형식으로 커밋을 제안합니다.

### 5. 자가 개선 제안 프로토콜 (Meta-Learning Protocol)

*   문제 해결 과정에서 배운 점을 영구적인 지식으로 전환하기 위해 다음 프로토콜을 따릅니다.
    1.  **상황 인지 (Trigger) 정교화:**
        *   **'규칙 제안' 트리거 (기존):** 동일한 목표를 가진 명령이 **2회 이상 연속 실패** 후, 다른 접근 방식으로 **1회 성공**했을 경우.
        *   **'규칙 제안' 트리거 (추가/수정):**
            *   **새로운 규칙 제안:** 대화 중 저의 행동이 `GEMINI.md`의 지침을 충분히 따르지 못했거나, 사용자에게 더 나은 경험을 제공할 수 있는 새로운 프로세스/규칙이 필요하다고 판단될 경우, 즉시 사용자에게 `GEMINI.md` 업데이트를 제안합니다.
            *   **기존 규칙 명확화/강화 제안:** 기존 `GEMINI.md` 규칙의 해석에 모호함이 있었거나, 더 강력한 자동화/선제적 조치가 필요하다고 판단될 경우, 즉시 사용자에게 해당 규칙의 명확화 또는 강화를 제안합니다.
        *   **'규칙 확정' 트리거:** 새로운 성공 방식이 **3회 이상 문제없이 연속 성공**했을 경우.
    2.  **규칙 업데이트 제안:** 위 트리거 조건 충족 시, 성공한 해결책을 `GEMINI.md`에 추가/확정할 것을 사용자에게 제안합니다.

---

## VI. 변경 이력 (Changelog)

*   **v1.3 (2025-07-22):** 자가 개선(Meta-Learning) 프로토콜, 로그 정정 SOP, PowerShell 기반 안정적 파일 삭제, 상세 과정 로깅 규칙 추가.